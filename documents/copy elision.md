复制消除（Copy Elision） 是 C++ 编译器的一种优化技术，用于避免不必要的对象拷贝或移动操作，从而提升程序性能。以下是其核心概念和应用场景：

核心机制
直接构造：
编译器直接在目标位置构造对象，绕过临时对象的拷贝或移动操作。
优化时机：
常见于函数返回临时对象、抛出异常对象或传递临时对象到函数时。
常见场景
1. 返回值优化（RVO, Return Value Optimization）
当函数返回一个匿名临时对象时，编译器直接在调用方栈帧构造该对象，避免拷贝。

cpp
// 示例：RVO
std::string createString() {
    return std::string("Hello"); // 匿名临时对象，触发 RVO
}

std::string s = createString(); // 直接在 s 的存储位置构造对象
2. 具名返回值优化（NRVO, Named Return Value Optimization）
当函数返回一个局部具名对象时，编译器可能将其直接构造到调用方的目标位置。

cpp
// 示例：NRVO（依赖编译器实现，非强制）
std::string createString() {
    std::string str("Hello");
    return str; // 具名对象，可能触发 NRVO
}

std::string s = createString(); // 可能直接在 s 的存储位置构造 str
3. 临时对象传递
将临时对象直接传递给函数参数时，编译器可能直接在参数位置构造对象。

cpp
void process(std::string s);

process(std::string("Hello")); // 直接在参数位置构造 s，避免拷贝
C++17 标准的变化
强制复制消除：
在以下场景中，编译器必须消除拷贝/移动操作（此前为可选优化）：
函数返回一个与返回类型相同的类类型临时对象。
抛出或捕获异常对象时。
示例：
cpp
// C++17 强制消除拷贝
T create() {
    return T(); // 直接构造到调用方，无拷贝
}
T t = create();
对代码的影响
构造函数调用次数减少：
拷贝/移动构造函数可能被跳过，即使它们有副作用。

cpp
struct A {
    A() {}
    A(const A&) { std::cout << "Copy"; } // 可能不被调用
};

A getA() { return A(); }
A a = getA(); // 无输出（拷贝构造函数被消除）
依赖副作用的代码风险：
若代码依赖拷贝/移动构造函数的副作用（如日志），需谨慎使用复制消除。

强制消除的限制
仅适用于纯右值（prvalue）：
如返回的临时对象，而非具名对象（此时仍可能优化，但非强制）。
不适用于需要类型转换的场景：
例如返回基类类型但实际对象是派生类时，可能无法消除。
总结
复制消除是提升 C++ 程序性能的关键优化。
C++17 起，部分场景的复制消除由可选优化变为强制要求。
编写代码时，避免依赖拷贝/移动构造函数的副作用，以兼容不同编译器的优化策略。