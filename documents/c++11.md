## auto
A placeholder type specifier designates a placeholder type that will be replaced later, typically by deduction from an initializer.
## decltype
Inspects the declared type of an entity or the type and value category of an expression.

## function declaration

__func__
Within the function body, the function-local predefined variable __func__ is defined as if by

```cpp
static const char __func__[] = "function-name";

#include <iostream>
 
void Foo() { std::cout << __func__ << ' '; }
 
struct Bar
{
    Bar() { std::cout << __func__ << ' '; }
    ~Bar() { std::cout << __func__ << ' '; }
    struct Pub { Pub() { std::cout << __func__ << ' '; } };
};
 
int main()
{
    Foo();
    Bar bar;
    Bar::Pub pub;
}
```
## Function contract specifiers
Precondition assertions
A precondition assertion is associated with entering a function:
```cpp
int divide(int dividend, int divisor) pre(divisor != 0)
{
    return dividend / divisor;
}
 
double square_root(double num) pre(num >= 0)
{
    return std::sqrt(num);
}
```
Postcondition assertions
A postcondition assertion is associated with exiting a function normally.
```cpp
int absolute_value(int num) post(r : r >= 0)
{
    return std::abs(num);
}
 
double sine(double num) post(r : r >= -1.0 && r <= 1.0)
{
    if (std::isnan(num) || std::isinf(num))
        // exiting via an exception never causes contract violation
        throw std::invalid_argument("Invalid argument");
    return std::sin(num);
}
```

## noexcept
no exection will be thrown in the function

## final specifier 
Specifies that a virtual function cannot be overridden in a derived class, or that a class cannot be derived from.
```cpp
struct Base
{
    virtual void foo();
};
 
struct A : Base
{
    void foo() final; // Base::foo is overridden and A::foo is the final override
    void bar() final; // Error: bar cannot be final as it is non-virtual
};
 
struct B final : A // struct B is final
{
    void foo() override; // Error: foo cannot be overridden as it is final in A
};
 
struct C : B {}; // Error: B is final
```

## Reference declaration
1) Lvalue reference declarator: the declaration S& D; declares D as an lvalue reference to the type determined by decl-specifier-seq S.
2) Rvalue reference declarator: the declaration S&& D; declares D as an rvalue reference to the type determined by decl-specifier-seq S.
Rvalue exten the lifetime of temp value like wstring&& k=L"ddd". only one L"ddd" exist in the whole life time which is referenced by k.

## Forwarding references
Forwarding references are a special kind of references that **preserve the value category of a function argument**, making it possible to forward it by means of std::forward. Forwarding references are either:

1) function parameter of a function template declared as rvalue reference to cv-unqualified type template parameter of that same function template:
2) auto&& except when deduced from a brace-enclosed initializer list or, when representing a template parameter of a class template during class template argument deduction(since C++17)

## Type-inaccessible references
Attempting to bind a reference to an object where the converted initializer is an lvalue(until C++11)a glvalue(since C++11) through which the object is not type-accessible results in undefined behavior:

```cpp
char x alignas(int);
 
int& ir = *reinterpret_cast<int*>(&x); // undefined behavior:
                                       // initializer refers to char object
```

## Move constructors
A move constructor is a constructor which can be called with an argument of the same class type and copies the content of the argument, possibly mutating the argument.

```cpp
struct X
{
    X(X&& other); // move constructor
//  X(X other);   // Error: incorrect parameter type
};
 
union Y
{
    Y(Y&& other, int num = 1); // move constructor with multiple parameters
//  Y(Y&& other, int num);     // Error: `num` has no default argument
};
```
The move constructor is typically called when an object is initialized (by direct-initialization or copy-initialization) from rvalue (xvalue or prvalue)(until C++17)xvalue(since C++17) of the same type, including

initialization: T a = std::move(b); or T a(std::move(b));, where b is of type T;
function argument passing: f(std::move(a));, where a is of type T and f is void f(T t);
function return: return a; inside a function such as T f(), where a is of type T which has a move constructor.
When the initializer is a prvalue, the move constructor call is often optimized out(until C++17)never made(since C++17), see copy elision.

## Move assignment operator
A move assignment operator is a non-template non-static member function with the name operator= that can be called with an argument of the same class type and copies the content of the argument, possibly mutating the argument.
```cpp
struct X
{
    X& operator=(X&& other);    // move assignment operator
//  X operator=(const X other); // Error: incorrect parameter type
};
 
union Y
{
    // move assignment operators can have syntaxes not listed above,
    // as long as they follow the general function declaration syntax
    // and do not viloate the restrictions listed above
    auto operator=(Y&& other) -> Y&;       // OK: trailing return type
    Y& operator=(this Y&& self, Y& other); // OK: explicit object parameter
//  Y& operator=(Y&&, int num = 1);        // Error: has other non-object parameters
};
```
 If both copy and move assignment operators are provided, overload resolution selects the move assignment if the argument is an rvalue (either a prvalue such as a nameless temporary or an xvalue such as the result of std::move), and selects the copy assignment if the argument is an lvalue (named object or a function/operator returning lvalue reference). If only the copy assignment is provided, all argument categories select it (as long as it takes its argument by value or as reference to const, since rvalues can bind to const references), which makes copy assignment the fallback for move assignment, when move is unavailable.

 ## Enumeration declaration
 An enumeration is a distinct type whose value is restricted to a range of values (see below for details), which may include several explicitly named constants ("enumerators").

The values of the constants are values of an integral type known as the underlying type of the enumeration. An enumeration has the same size, value representation, and alignment requirements as its underlying type. Furthermore, each value of an enumeration has the same representation as the corresponding value of the underlying type.

An enumeration can be initialized from an integer without a cast, using list initialization, if all of the following are true:

The initialization is direct-list-initialization.
The initializer list has only a single element.
The enumeration is either scoped or unscoped with underlying type fixed.
The conversion is non-narrowing.
This makes it possible to introduce new integer types (e.g. SafeInt) that enjoy the same existing calling conventions as their underlying integer types, even on ABIs that penalize passing/returning structures by value.
```cpp
enum byte : unsigned char {}; // byte is a new integer type; see also std::byte (C++17)
byte b{42};        // OK as of C++17 (direct-list-initialization)
byte c = {42};     // error
byte d = byte{42}; // OK as of C++17; same value as b
byte e{-1};        // error
 
struct A { byte b; };
A a1 = {{42}};     // error (copy-list-initialization of a constructor parameter)
A a2 = {byte{42}}; // OK as of C++17
 
void f(byte);
f({42}); // error (copy-list-initialization of a function parameter)
 
enum class Handle : std::uint32_t { Invalid = 0 };
Handle h{42}; // OK as of C++17
```

## constexpr specifier 
The constexpr specifier declares that it is possible to evaluate the value of the entities **at compile time**. Such entities can then be used where only compile time constant expressions are allowed (provided that appropriate function arguments are given).

## union
A union is a special class type that can hold only one of its non-static data members at a time.
A union can have member functions (including constructors and destructors), but not virtual functions.
A union cannot have base classes and cannot be used as a base class.
if members of a union are classes with user-defined constructors and destructors, to switch the active member, **explicit destructor and placement new are generally needed**
we can use std::variant after c++17 instead of union