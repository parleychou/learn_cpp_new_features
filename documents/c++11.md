## auto
A placeholder type specifier designates a placeholder type that will be replaced later, typically by deduction from an initializer.
## decltype
Inspects the declared type of an entity or the type and value category of an expression.

## function declaration

__func__
Within the function body, the function-local predefined variable __func__ is defined as if by

```cpp
static const char __func__[] = "function-name";

#include <iostream>
 
void Foo() { std::cout << __func__ << ' '; }
 
struct Bar
{
    Bar() { std::cout << __func__ << ' '; }
    ~Bar() { std::cout << __func__ << ' '; }
    struct Pub { Pub() { std::cout << __func__ << ' '; } };
};
 
int main()
{
    Foo();
    Bar bar;
    Bar::Pub pub;
}
```
## Function contract specifiers
Precondition assertions
A precondition assertion is associated with entering a function:
```cpp
int divide(int dividend, int divisor) pre(divisor != 0)
{
    return dividend / divisor;
}
 
double square_root(double num) pre(num >= 0)
{
    return std::sqrt(num);
}
```
Postcondition assertions
A postcondition assertion is associated with exiting a function normally.
```cpp
int absolute_value(int num) post(r : r >= 0)
{
    return std::abs(num);
}
 
double sine(double num) post(r : r >= -1.0 && r <= 1.0)
{
    if (std::isnan(num) || std::isinf(num))
        // exiting via an exception never causes contract violation
        throw std::invalid_argument("Invalid argument");
    return std::sin(num);
}
```

## noexcept
no exection will be thrown in the function

## final specifier 
Specifies that a virtual function cannot be overridden in a derived class, or that a class cannot be derived from.
```cpp
struct Base
{
    virtual void foo();
};
 
struct A : Base
{
    void foo() final; // Base::foo is overridden and A::foo is the final override
    void bar() final; // Error: bar cannot be final as it is non-virtual
};
 
struct B final : A // struct B is final
{
    void foo() override; // Error: foo cannot be overridden as it is final in A
};
 
struct C : B {}; // Error: B is final
```

## Reference declaration
1) Lvalue reference declarator: the declaration S& D; declares D as an lvalue reference to the type determined by decl-specifier-seq S.
2) Rvalue reference declarator: the declaration S&& D; declares D as an rvalue reference to the type determined by decl-specifier-seq S.
Rvalue exten the lifetime of temp value like wstring&& k=L"ddd". only one L"ddd" exist in the whole life time which is referenced by k.

## Forwarding references
Forwarding references are a special kind of references that **preserve the value category of a function argument**, making it possible to forward it by means of std::forward. Forwarding references are either:

1) function parameter of a function template declared as rvalue reference to cv-unqualified type template parameter of that same function template:
2) auto&& except when deduced from a brace-enclosed initializer list or, when representing a template parameter of a class template during class template argument deduction(since C++17)

## Type-inaccessible references
Attempting to bind a reference to an object where the converted initializer is an lvalue(until C++11)a glvalue(since C++11) through which the object is not type-accessible results in undefined behavior:

```cpp
char x alignas(int);
 
int& ir = *reinterpret_cast<int*>(&x); // undefined behavior:
                                       // initializer refers to char object
```